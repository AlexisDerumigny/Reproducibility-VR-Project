---
title: "Analysis of dependence between Time and UX"
date: "2023-04-19"
output:
  html_document:
    toc: true
    toc_depth: 2
---
This file is for the two hypothesis:
- The time taken impacts certain factors of the user experience.
The time taken initially was expected to impact ...
From the correlation matrix this was further filtered to only test this for ..., since these seemed to give the largest correlations.

- 





To calculate this correlations, we considered taking the separate questions as random effect, similar to the UX calculation. However since there was no surety that the average of the correlations would give a result with the same meaning as the correlation of the averages, the latter option was chosen since this for sure gave the statistical test desired, although with slightly less statistical power. 
cor((x1 + x2 + x3)/3, y) = correlation between averages
1/3(cor(x1, y) + cor(x2, y) + cor(x3, y)) = average of correlations (would give more statistical power treating subquestions as random effect, but possibly does not answer the question whether one UX group correlates with another on average.)



```{r setup}
#install.packages(c("corrplot", "tidyverse", "knitr"))
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev = 'svg') # set output device to svg
library(tidyverse)

options(width = 150) # https://bookdown.org/yihui/rmarkdown-cookbook/text-width.html
```


# 1- Data loading and preprocessing


```{r}
source("preparingTimeData.R")
source("preparingUXdata.R")
```


```{r}
dataUXTime = full_join(
  x = dataTime |> select(! all_of("Index")),
  y = dataUX |> mutate(ParticipantID = as.integer(ParticipantID)),
  by = c("ParticipantID", "LocomotionTechnique"),
  suffix = c(".x", ".y"),
  keep = NULL
)
```


# 2- Visualization

```{r}
allQuestionsGroups = unique(data_questions$QuestionGroup)
for (i_QuestionGroup in 1:length(allQuestionsGroups))
{
  nameQuestionGroup = allQuestionsGroups[i_QuestionGroup]
  selectedQuestions = data_questions[
    data_questions$QuestionGroup == nameQuestionGroup, ]
  
  nameQuestions = selectedQuestions$Question_description
  
  df_selectCol = dataUXTime[, nameQuestions, drop = FALSE]
  for (i_Question in 1:length(nameQuestions)){
    nameOfQuestion = nameQuestions[i_Question]
    if (selectedQuestions[i_Question, "ToBeInverted"] == 0){
      df_selectCol[, nameOfQuestion] = - abs(3 - df_selectCol[, nameOfQuestion])
    }
  }
  
  dataUXTime[, nameQuestionGroup] = rowMeans(df_selectCol)
}
```


```{r, fig.height=12, fig.width=12}
dataUXTime$completionTimeOp = - dataUXTime$completionTime #invert, so better = less time taken

selectedQuestions = c(allQuestionsGroups, "completionTimeOp",
                      "I think the virtual speed felt natural compared to normal walking",
                      "I wanted to move through the virtual environment")

corMat = cor(dataUXTime[, selectedQuestions], use = "pairwise.complete.obs")
corrplot::corrplot(corMat, order = "hclust")
```


```{r, fig.height=12, fig.width=12}
corTests = dataUXTime[, selectedQuestions] |> 
  corrplot::cor.mtest(use = "pairwise.complete.obs")

corrplot::corrplot(corMat, p.mat = corTests$p, sig.level = 0.05, order = "hclust",
                   addrect = 2)
```
```{r}
# printed this and double checked this plotting a line in raw values in Google Sheets, and it is indeed the more time taken, the better they rate the direction...
print(dataUXTime$`Direction`)
print(dataUXTime$completionTime)
```
```{r, fig.height=10, fig.width=10}
## These were some plots we made earlier because of an error in the data. We were trying to figure out why some values were unlogically negatively correlated, and checked if this was due to the Simpsons effect, where if and extra variable (aka participant) is not taken into account, the trend will be different. (For each participant it would go upward, while in total it would go downward). This was not the case, and in the end the weird values were caused by a wrong double inversion (therefore not inverting questions that should be inverted).

ggplot(dataUXTime) +
  geom_jitter(aes(completionTime, Direction), width = 0.1, height = 0.1)
  
dataUXTime |>
  mutate(ParticipantID = factor(ParticipantID)) |>
  ggplot() +
  geom_jitter(aes(completionTime, Direction, color = ParticipantID), width = 0.1, height = 0.1)

dataUXTime |>
  mutate(ParticipantID = factor(ParticipantID)) |>
  ggplot() +
  geom_jitter(aes(completionTime, Direction), width = 0.01, height = 0.01) +
  facet_wrap(~ ParticipantID)
```  




# 3- Modeling



